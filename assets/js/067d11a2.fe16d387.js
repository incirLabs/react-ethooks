"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[298],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=n.createContext({}),s=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(r),h=o,m=d["".concat(p,".").concat(h)]||d[h]||u[h]||a;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},1377:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var n=r(7462),o=(r(7294),r(3905));const a={id:"ethooks-provider",title:"EthooksProvider",sidebar_position:1},i=void 0,l={unversionedId:"components/ethooks-provider",id:"components/ethooks-provider",title:"EthooksProvider",description:"EthooksProvider is a React Context Provider that provides all the hooks and functions to interact with Ethereum.",source:"@site/docs/components/ethooks-provider.md",sourceDirName:"components",slug:"/components/ethooks-provider",permalink:"/react-ethooks/components/ethooks-provider",draft:!1,editUrl:"https://github.com/incirLabs/react-ethooks/blob/main/docs/docs/components/ethooks-provider.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"ethooks-provider",title:"EthooksProvider",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Components",permalink:"/react-ethooks/category/components"},next:{title:"Hooks",permalink:"/react-ethooks/category/hooks"}},p={},s=[{value:"Usage",id:"usage",level:2},{value:"Props",id:"props",level:2},{value:"provider",id:"provider",level:3},{value:"chains",id:"chains",level:3},{value:"autoConnect",id:"autoconnect",level:3}],c={toc:s},d="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"EthooksProvider is a React Context Provider that provides all the hooks and functions to interact with Ethereum."),(0,o.kt)("p",null,"It is required to wrap your root component with EthooksProvider so that all the hooks can access the provider."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"You should only wrap your root component with EthooksProvider once. If you wrap it multiple times or use more than once, it will cause unexpected behavior, such as different states for hooks.")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"You should pass ",(0,o.kt)("inlineCode",{parentName:"p"},"any")," as the chain argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"ethers provider")," (not the EthooksProvider) to avoid unexpected behaviors when the network changes.\nThis is not a problem since EthooksProvider will handle the network changes and update the provider and state accordingly.")),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"In this case, we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"Web3Provider")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"ethers")," library."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import {EthooksProvider} from '@incirlabs/react-ethooks';\nimport {ethers} from 'ethers';\nimport {useMemo} from 'react';\n\nexport default function Main() {\n  // NOTE: \"any\" is required as the chain argument to ethers provider.\n  // https://github.com/ethers-io/ethers.js/issues/866\n  // Since we are using EthooksProvider to handle network changes, this is not a problem.\n  const provider = useMemo(() => new ethers.providers.Web3Provider(window.ethereum, 'any'), []);\n\n  return (\n    <EthooksProvider provider={provider} chains={['mainnet', 'goerli']} autoConnect>\n      <App />\n    </EthooksProvider>\n  );\n}\n")),(0,o.kt)("h2",{id:"props"},"Props"),(0,o.kt)("h3",{id:"provider"},"provider"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"provider")," is the provider that will be used to interact with Ethereum."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"string"),(0,o.kt)("td",{parentName:"tr",align:null},"Required")))),(0,o.kt)("h3",{id:"chains"},"chains"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"chains")," is an array of ",(0,o.kt)("a",{parentName:"p",href:"../types#chain"},"chain names or ",(0,o.kt)("inlineCode",{parentName:"a"},"ChainObject"))," that will be allowed to connect to."),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"chains")," is not provided, it will allow all chains."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Array<",(0,o.kt)("a",{parentName:"td",href:"../types#chain"},"Chain"),">"),(0,o.kt)("td",{parentName:"tr",align:null},"undefined")))),(0,o.kt)("h3",{id:"autoconnect"},"autoConnect"),(0,o.kt)("p",null,"If it is ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," it will automatically tries to connect to the wallet on mount."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"boolean"),(0,o.kt)("td",{parentName:"tr",align:null},"false")))))}u.isMDXComponent=!0}}]);